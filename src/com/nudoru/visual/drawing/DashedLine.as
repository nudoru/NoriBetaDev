  /**** DashedLine.as  	April 2009** @author Charles S.Davis** Draws dashed & dotted lines** Licensed under the MIT License* * Copyright (c) 2009 Charles S.Davis* * Permission is hereby granted, free of charge, to any person obtaining a copy of* this software and associated documentation files (the "Software"), to deal in* the Software without restriction, including without limitation the rights to* use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of* the Software, and to permit persons to whom the Software is furnished to do so,* subject to the following conditions:* * The above copyright notice and this permission notice shall be included in all* copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.* * http://www.opensource.org/licenses/mit-license.php*    */package com.nudoru.visual.drawing{	import flash.display.Sprite;		public class DashedLine extends Sprite	{		public var lineLength:uint		public var dashWidth:uint;		public var dashHeight:uint;		public var dashSpacing:uint;		public var dashColor:uint;		public var dashOffset:int;				private var xPos:uint;		private var numberOfDashes:Number;		private var totalLength:uint;		private var endWidth:uint;				/**		 *		PARAMS:		 *				@param  		lineLength			uint		total length of line to bedrawn		 *				@param			dashWidth			uint		width of each dashezoid		 * 	 			@param			dashHeight			uint    	height or each dashezoid		 *				@param			dashSpacing			uint		spacing between each dash		 *				@param			dashColor			uint		color of each dashes		 *				@param			dashOffset			uint		Optional: dashOffset (in pixels) for slope of vertical sides.  		 *                                                              Defaults to 0 which creates rectangular dash shape		 */		public function DashedLine( lineLength:uint, dashWidth:uint, dashHeight:uint, dashSpacing:uint, dashColor:uint, dashOffset:int=0 ):void		{			this.lineLength  = lineLength;			this.dashWidth   = dashWidth;			this.dashHeight  = dashHeight;			this.dashSpacing = dashSpacing;			this.dashColor   = dashColor;			this.dashOffset  = dashOffset;						drawDashedLine();		}				/**		 *		Draw the dashed line in 3 sections: the left end segment, all middle segment & right end segment		 */		private function drawDashedLine():void		{			// calculate number of full sized dashes required			numberOfDashes = Math.floor(lineLength / (dashWidth + dashSpacing));						// calculate total length of line composed of full sized dashes			totalLength = numberOfDashes * (dashWidth + dashSpacing);						// total width of each end segment			endWidth = (lineLength - totalLength) / 2;						// if endWidth is less than dash width, decrement number 			// of dashes & recalc total length and endWidth			if (endWidth < dashWidth)			{				numberOfDashes--;				totalLength -= (dashWidth + dashSpacing);				endWidth = (lineLength - totalLength) / 2;			}						// draw left hand beginning segment			if ( endWidth > 4 )			{				this.graphics.beginFill( dashColor, 1 );				this.graphics.moveTo( 0, 0 );				this.graphics.lineTo( endWidth, 0 );				this.graphics.lineTo( endWidth-dashOffset, dashHeight );				this.graphics.lineTo( 0, dashHeight );				this.graphics.moveTo( 0, 0 );				this.graphics.endFill();			}						// reset starting point of first full sized dash			xPos = endWidth + dashSpacing;									// draw all full sized dashes			for ( var j:uint=0; j<numberOfDashes; j++)			{				this.graphics.beginFill( dashColor, 1 );				this.graphics.moveTo( xPos, 0 );				this.graphics.lineTo( xPos+dashWidth, 0 );				this.graphics.lineTo( xPos+dashWidth-dashOffset, dashHeight );				this.graphics.lineTo( xPos-dashOffset, dashHeight );				this.graphics.moveTo( xPos, 0 );				this.graphics.endFill();								xPos += ( dashWidth + dashSpacing );			}			// calculate starting point of right end segment			xPos = endWidth + numberOfDashes * ( dashWidth + dashSpacing ) + dashSpacing;						// draw right end segment			if ( endWidth > 4 )			{				this.graphics.beginFill( dashColor, 1 );				this.graphics.moveTo( xPos, 0 );				this.graphics.lineTo( lineLength, 0 );				this.graphics.lineTo( lineLength, dashHeight );				this.graphics.lineTo( xPos-dashOffset, dashHeight );				this.graphics.lineTo( xPos, 0 );				this.graphics.endFill();			}		}	}}/**	USAGE  ******************************************************************* 			USAGE:import com.dtk.DashedLine;var newLine:DashedLine = new DashedLine ( lineLength, dashWidth, dashHeight, dashSpacing, dashOffset, dashColor );newLine.rotation = angle; // (optional - in degrees)newLine.x = x position;newLine.y = y position;addChild(newLine);******************************************************************************/