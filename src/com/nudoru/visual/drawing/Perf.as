/** * * Perf.as 	 Charles S.Davis 	May 2010 * * Draw grid of squares or circles * * * Licensed under the MIT License *  * Copyright (c) 2010 Charles S.Davis *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. *  * http://www.opensource.org/licenses/mit-license.php *     */package com.nudoru.visual.drawing{	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.display.BitmapData;		public class Perf extends Sprite	{		public var cellSize:uint;		public var perfSize:uint;		public var square:Boolean;		public var perfColor:uint;		public var perfAlpha:Number;		public var boardWidth:uint;		public var boardHeight:uint;				private var xPos:uint;		private var yPos:uint;		private var offset:uint;		private var xReps:uint;		private var yReps:uint;				/**		 *	PARAMS:		@param		cellSize		uint		width/height of base cell		 *				@param 		perfSize		uint		width/diameter of square/circle pattern		 *				@param 		square			Boolean		if true draw square pattern otherwise circular		 *				@param 		perfColor		uint        color of pattern		 *				@param		perfAlpha		Number		alpha transparency		 *				@param 		boardWidth 		uint		width of area to be filled		 *				@param		boardHeight		uint      	height of area to be filled		 *		 *		 *	USAGE:		import com.dtk.Checkerboard;  		 *		 *				// new instance of Checkerboard Class		 *				var cb:Checkerboard = new Checkerboard( cellSize, color_1, color_2, boardWidth, boardHeight );		 *				cb.x = x;		 *				cb.y = y;		 *				cb.alpha = n;  // optional		 *				addChild( cb );		 */		public function Perf ( cellSize:uint, perfSize:uint, square:Boolean, perfColor:uint, perfAlpha:Number, boardWidth:uint, boardHeight:uint ):void		{			this.cellSize    = cellSize;			this.perfSize    = perfSize;			this.square      = square;			this.perfColor   = perfColor;			this.perfAlpha   = perfAlpha;			this.boardWidth  = boardWidth;			this.boardHeight = boardHeight;						drawPattern( );		}				/**		 *	draw grid of square/circular pattern		 *		 */		private function drawPattern( ):void		{			// init starting x position			xPos = 0;						// pattern offset			offset = ( cellSize - perfSize ) / 2;						// number of horizontal & vertical repetitions			xReps  = boardWidth / cellSize;			yReps  = boardHeight / cellSize;						// loop through horizontal positions			for ( var i:uint=0; i<xReps; i++ )			{				// start at top				yPos = 0;								// loop through vertical reps				for ( var j:uint=0; j<yReps; j++ )				{					// draw square or circular sprite					var p:Sprite = new Sprite( );					p.graphics.beginFill( perfColor, perfAlpha );										if ( square )					{						p.graphics.drawRect( xPos+offset, yPos+offset, perfSize, perfSize );					}					else					{						p.graphics.drawCircle( xPos+cellSize/2, yPos+cellSize/2, perfSize/2 ); 					}										p.graphics.endFill( );					addChild( p );										// increment y position					yPos += cellSize;				}								// increment x position				xPos += cellSize;			}					}	}}